// SPDX-License-Identifier: BSD-2-Clause
//
// Copyright (c) 2025 The FreeBSD Foundation.
//
// This software was developed by Hayzam Sherif <hayzam@alchemilla.io>
// of Alchemilla Ventures Pvt. Ltd. <hello@alchemilla.io>,
// under sponsorship from the FreeBSD Foundation.

package jail

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"

	"github.com/alchemillahq/gzfs"
	"github.com/alchemillahq/sylve/internal/config"
	jailModels "github.com/alchemillahq/sylve/internal/db/models/jail"
	networkModels "github.com/alchemillahq/sylve/internal/db/models/network"
	jailServiceInterfaces "github.com/alchemillahq/sylve/internal/interfaces/services/jail"
	networkServiceInterfaces "github.com/alchemillahq/sylve/internal/interfaces/services/network"
	systemServiceInterfaces "github.com/alchemillahq/sylve/internal/interfaces/services/system"
	"github.com/alchemillahq/sylve/internal/logger"
	"github.com/alchemillahq/sylve/pkg/utils"
	cpuid "github.com/klauspost/cpuid/v2"

	"gorm.io/gorm"
)

const JAIL_CONF_PREAMBLE = "# Sylve Jail Configuration File\n# Generated by Sylve - Editing this file manually is not recommended, changes will be overwritten.\n\n"

var _ jailServiceInterfaces.JailServiceInterface = (*Service)(nil)

type Service struct {
	DB             *gorm.DB
	NetworkService networkServiceInterfaces.NetworkServiceInterface
	System         systemServiceInterfaces.SystemServiceInterface
	GZFS           *gzfs.Client

	crudMutex sync.Mutex
}

func NewJailService(
	db *gorm.DB,
	networkService networkServiceInterfaces.NetworkServiceInterface,
	systemService systemServiceInterfaces.SystemServiceInterface,
	gzfs *gzfs.Client) jailServiceInterfaces.JailServiceInterface {
	return &Service{
		DB:             db,
		NetworkService: networkService,
		System:         systemService,
		GZFS:           gzfs,
	}
}

func (s *Service) GetJails() ([]jailModels.Jail, error) {
	var jails []jailModels.Jail
	if err := s.DB.
		Preload("Storages").
		Preload("JailHooks").
		Preload("Networks").
		Preload("Networks.MacAddressObj").
		Preload("Networks.MacAddressObj.Entries").
		Preload("Networks.MacAddressObj.Resolutions").
		Preload("Networks.IPv4Obj").
		Preload("Networks.IPv4Obj.Entries").
		Preload("Networks.IPv4Obj.Resolutions").
		Preload("Networks.IPv4GwObj").
		Preload("Networks.IPv4GwObj.Entries").
		Preload("Networks.IPv4GwObj.Resolutions").
		Preload("Networks.IPv6Obj").
		Preload("Networks.IPv6Obj.Entries").
		Preload("Networks.IPv6Obj.Resolutions").
		Preload("Networks.IPv6GwObj").
		Preload("Networks.IPv6GwObj.Entries").
		Preload("Networks.IPv6GwObj.Resolutions").
		Find(&jails).Error; err != nil {
		logger.L.Error().Err(err).Msg("get_jails: failed to fetch jails")
		return nil, fmt.Errorf("failed_to_fetch_jails: %w", err)
	}
	return jails, nil
}

func (s *Service) GetJail(id uint) (*jailModels.Jail, error) {
	var jail jailModels.Jail
	if err := s.DB.
		Preload("Storages").
		Preload("JailHooks").
		Preload("Snapshots", func(db *gorm.DB) *gorm.DB {
			return db.Order("created_at ASC, id ASC")
		}).
		Preload("Networks").
		Preload("Networks.MacAddressObj").
		Preload("Networks.MacAddressObj.Entries").
		Preload("Networks.MacAddressObj.Resolutions").
		Preload("Networks.IPv4Obj").
		Preload("Networks.IPv4Obj.Entries").
		Preload("Networks.IPv4Obj.Resolutions").
		Preload("Networks.IPv4GwObj").
		Preload("Networks.IPv4GwObj.Entries").
		Preload("Networks.IPv4GwObj.Resolutions").
		Preload("Networks.IPv6Obj").
		Preload("Networks.IPv6Obj.Entries").
		Preload("Networks.IPv6Obj.Resolutions").
		Preload("Networks.IPv6GwObj").
		Preload("Networks.IPv6GwObj.Entries").
		Preload("Networks.IPv6GwObj.Resolutions").
		First(&jail, "id = ?", id).Error; err != nil {
		logger.L.Error().Err(err).Msgf("get_jail: failed to fetch jail with id %d", id)
		return nil, fmt.Errorf("failed_to_fetch_jail: %w", err)
	}

	return &jail, nil
}

func (s *Service) GetJailByCTID(ctId uint) (*jailModels.Jail, error) {
	var jail jailModels.Jail
	if err := s.DB.
		Preload("Storages").
		Preload("JailHooks").
		Preload("Snapshots", func(db *gorm.DB) *gorm.DB {
			return db.Order("created_at ASC, id ASC")
		}).
		Preload("Networks").
		Preload("Networks.MacAddressObj").
		Preload("Networks.MacAddressObj.Entries").
		Preload("Networks.MacAddressObj.Resolutions").
		Preload("Networks.IPv4Obj").
		Preload("Networks.IPv4Obj.Entries").
		Preload("Networks.IPv4Obj.Resolutions").
		Preload("Networks.IPv4GwObj").
		Preload("Networks.IPv4GwObj.Entries").
		Preload("Networks.IPv4GwObj.Resolutions").
		Preload("Networks.IPv6Obj").
		Preload("Networks.IPv6Obj.Entries").
		Preload("Networks.IPv6Obj.Resolutions").
		Preload("Networks.IPv6GwObj").
		Preload("Networks.IPv6GwObj.Entries").
		Preload("Networks.IPv6GwObj.Resolutions").
		First(&jail, "ct_id = ?", ctId).Error; err != nil {
		logger.L.Error().Err(err).Msgf("get_jail_by_ctid: failed to fetch jail with ct_id %d", ctId)
		return nil, fmt.Errorf("failed_to_fetch_jail_by_ctid: %w", err)
	}

	return &jail, nil
}

func (s *Service) GetJailsSimple() ([]jailServiceInterfaces.SimpleList, error) {
	var jails []jailModels.Jail

	if err := s.DB.Model(&jailModels.Jail{}).Select("id, name, ct_id").Find(&jails).Error; err != nil {
		logger.L.Error().Err(err).Msg("get_jails_simple: failed to fetch jails")
		return nil, fmt.Errorf("failed_to_fetch_jails_simple: %w", err)
	}

	var list []jailServiceInterfaces.SimpleList
	var states []jailServiceInterfaces.State

	states, err := s.GetStates()
	if err != nil {
		return nil, fmt.Errorf("failed_to_get_states: %w", err)
	}

	for _, jail := range jails {
		var state string

		for _, s := range states {
			if s.CTID == jail.CTID {
				state = s.State
				break
			}
		}

		list = append(list, jailServiceInterfaces.SimpleList{
			ID:    jail.ID,
			Name:  jail.Name,
			CTID:  jail.CTID,
			State: state,
		})
	}

	return list, nil
}

func (s *Service) ValidateCreate(ctx context.Context, data jailServiceInterfaces.CreateJailRequest) error {
	if data.Name == "" || !utils.IsValidVMName(data.Name) {
		return fmt.Errorf("invalid_vm_name")
	}

	if data.Hostname != "" && !utils.IsValidHostname(data.Hostname) {
		return fmt.Errorf("invalid_hostname")
	}

	if data.CTID == nil || *data.CTID <= 0 || *data.CTID > 9999 {
		return fmt.Errorf("invalid_ct_id")
	}

	if data.Description != "" && (len(data.Description) < 1 || len(data.Description) > 1024) {
		return fmt.Errorf("invalid_description")
	}

	if data.Type != jailModels.JailTypeFreeBSD && data.Type != jailModels.JailTypeLinux {
		return fmt.Errorf("invalid_jail_type")
	}

	pools, err := s.System.GetUsablePools(ctx)
	if err != nil {
		return fmt.Errorf("failed_to_get_usable_pools: %w", err)
	}

	foundPool := ""
	for _, pool := range pools {
		if pool.Name == data.Pool {
			foundPool = pool.Name
			break
		}
	}

	if foundPool == "" {
		return fmt.Errorf("pool_not_found")
	}

	if data.Base != "" {
		ex, err := s.FindBaseByUUID(data.Base)
		if err != nil {
			return err
		}

		if _, err := os.Stat(ex); os.IsNotExist(err) {
			return fmt.Errorf("base_path_does_not_exist")
		}
	} else {
		return fmt.Errorf("download_uuid_required")
	}

	existingDataset, err := s.GZFS.ZFS.Get(ctx, fmt.Sprintf("%s/sylve/jails/%d", foundPool, *data.CTID), false)
	if err != nil {
		if !strings.Contains(err.Error(), "dataset does not exist") {
			return fmt.Errorf("failed_to_get_existing_datasets: %w", err)
		}
	}

	if existingDataset != nil {
		return fmt.Errorf("jail_base_fs_with_ctid_already_exists")
	}

	swAvailable := true
	mac := uint(0)
	dhcp := false
	slaac := false

	if data.SwitchName == "" {
		return fmt.Errorf("switch_name_required")
	} else if strings.ToLower(data.SwitchName) == "inherit" || strings.ToLower(data.SwitchName) == "none" {
		swAvailable = false
	}

	if swAvailable {
		found := false

		var stdSwitch networkModels.StandardSwitch
		if err := s.DB.First(&stdSwitch, "name = ?", data.SwitchName).Error; err == nil {
			found = true
		}

		var manualSwitch networkModels.ManualSwitch
		if err := s.DB.First(&manualSwitch, "name = ?", data.SwitchName).Error; err == nil {
			found = true
		}

		if !found {
			return fmt.Errorf("standard_switch_not_found")
		}
	}

	if data.MAC != nil {
		mac = uint(*data.MAC)
		if mac != 0 && swAvailable {
			used, _, err := s.NetworkService.IsObjectUsed(mac)
			if err != nil {
				return fmt.Errorf("failed_to_check_mac_usage: %w", err)
			}

			if used {
				return fmt.Errorf("mac_already_used")
			}
		}
	}

	if data.DHCP != nil {
		dhcp = *data.DHCP
	}

	if data.SLAAC != nil {
		slaac = *data.SLAAC
	}

	if swAvailable {
		if !dhcp {
			if data.IPv4 != nil {
				ipv4Id := uint(*data.IPv4)
				if ipv4Id != 0 && data.IPv4Gw != nil {
					ipv4GwId := uint(*data.IPv4Gw)
					if ipv4GwId == 0 {
						return fmt.Errorf("invalid_ipv4_gateway")
					}

					isUsed, _, err := s.NetworkService.IsObjectUsed(ipv4Id)
					if err != nil {
						return fmt.Errorf("failed_to_check_ipv4_usage: %w", err)
					}

					if isUsed {
						return fmt.Errorf("ipv4_already_used")
					}
				}
			}
		}

		if !slaac {
			if data.IPv6 != nil {
				ipv6Id := uint(*data.IPv6)

				if ipv6Id != 0 && data.IPv6Gw != nil {
					ipv6GwId := uint(*data.IPv6Gw)
					if ipv6GwId == 0 {
						return fmt.Errorf("invalid_ipv6_gateway")
					}

					isUsed, _, err := s.NetworkService.IsObjectUsed(ipv6Id)
					if err != nil {
						return fmt.Errorf("failed_to_check_ipv6_usage: %w", err)
					}

					if isUsed {
						return fmt.Errorf("ipv6_already_used")
					}
				}
			}
		}
	}

	if data.Type == jailModels.JailTypeLinux {
		if dhcp || slaac {
			return fmt.Errorf("linux_jails_cannot_use_dhcp_or_slaac")
		}

		if !((data.IPv4 == nil && data.IPv6 == nil) ||
			(data.IPv4 != nil && data.IPv6 != nil && *data.IPv4 == 0 && *data.IPv6 == 0)) {
			return fmt.Errorf("linux_jails_cannot_use_ip4_or_ip6")
		}
	}

	if !utils.IsValidJailAllowedOpts(data.AllowedOptions) {
		return fmt.Errorf("invalid_jail_allowed_options")
	}

	if data.StartOrder < 0 {
		return fmt.Errorf("start_order_must_be_greater_than_or_equal_to_0")
	}

	return nil
}

func (s *Service) CreateHardwareConfig(data jailModels.Jail) (string, string, error) {
	cpuCores := data.Cores
	memory := data.Memory

	cpuCfg := ""
	memoryCfg := ""

	ctidHash := utils.HashIntToNLetters(int(data.CTID), 5)

	jails, err := s.GetJails()
	if err != nil {
		return "", "", fmt.Errorf("failed_to_get_jails: %w", err)
	}

	numLogicalCores := cpuid.CPU.LogicalCores
	coreUsage := map[int]int{}
	for _, jail := range jails {
		for _, core := range jail.CPUSet {
			coreUsage[core]++
		}
	}

	type CoreCount struct {
		Core  int
		Count int
	}

	var allCores []CoreCount
	for i := 0; i < numLogicalCores; i++ {
		allCores = append(allCores, CoreCount{Core: i, Count: coreUsage[i]})
	}

	sort.Slice(allCores, func(i, j int) bool {
		return allCores[i].Count < allCores[j].Count
	})

	if cpuCores > 0 && len(allCores) > 0 {
		selectedCores := []int{}
		for i := 0; i < cpuCores && i < len(allCores); i++ {
			selectedCores = append(selectedCores, allCores[i].Core)
		}
		if len(selectedCores) > 0 {
			coreListStr := strings.Trim(strings.Replace(fmt.Sprint(selectedCores), " ", ",", -1), "[]")
			cpuCfg = fmt.Sprintf("cpuset -l %s -j %s", coreListStr, ctidHash)
		}
	}

	if memory > 0 {
		memoryMB := memory / (1024 * 1024)
		memoryCfg = fmt.Sprintf("rctl -a jail:%s:memoryuse:deny=%dM", ctidHash, memoryMB)
	}

	return cpuCfg, memoryCfg, nil
}

func (s *Service) CreateJailConfig(data jailModels.Jail, mountPoint string, mac string) (string, error) {
	ctid := data.CTID

	if mountPoint == "" {
		return "", fmt.Errorf("mount_point_not_found")
	}

	jailsPath, err := config.GetJailsPath()
	if err != nil {
		return "", fmt.Errorf("failed_to_get_jails_path: %w", err)
	}

	// Append devfs rules if provided
	if data.DevFSRuleset != "" {
		devFsRulesetPath := filepath.Join("/etc", "devfs.rules")
		f, err := os.OpenFile(devFsRulesetPath, os.O_APPEND|os.O_WRONLY, 0600)
		if err != nil {
			return "", fmt.Errorf("failed_to_open_devfs_rules_file: %w", err)
		}
		defer f.Close()

		rule := fmt.Sprintf("\n[devfsrules_jails_sylve_%d=%d]\n", ctid, ctid)
		rule += data.DevFSRuleset + "\n"
		if _, err := f.WriteString(rule); err != nil {
			return "", fmt.Errorf("failed_to_write_devfs_rules: %w", err)
		}
	}

	// Host-side jail directory (config/logs/scripts managed by Sylve)
	jailDir := filepath.Join(jailsPath, fmt.Sprintf("%d", ctid))
	hostScriptsDir := filepath.Join(jailDir, "scripts")
	if err := os.MkdirAll(hostScriptsDir, 0755); err != nil {
		return "", fmt.Errorf("failed_to_create_jail_scripts_directory: %w", err)
	}

	// Inside-jail scripts dir: /usr/local/sylve/scripts
	jailScriptsRelDir := filepath.Join("usr", "local", "sylve", "scripts")
	jailScriptsFsDir := filepath.Join(mountPoint, jailScriptsRelDir)
	if err := os.MkdirAll(jailScriptsFsDir, 0755); err != nil {
		return "", fmt.Errorf("failed_to_create_in_jail_scripts_directory: %w", err)
	}

	var rcConfPath string

	if data.Type == jailModels.JailTypeFreeBSD {
		rcConfPath = filepath.Join(mountPoint, "etc", "rc.conf")
		if _, err := os.Stat(rcConfPath); os.IsNotExist(err) {
			if err := os.WriteFile(rcConfPath, []byte(""), 0644); err != nil {
				return "", fmt.Errorf("failed_to_create_rc_conf: %w", err)
			}
		}
	}

	logPath := filepath.Join(jailDir, fmt.Sprintf("%d.log", ctid))

	writeScript := func(path, content string, executable bool) error {
		// If completely empty, just write a minimal shell script
		if strings.TrimSpace(content) == "" {
			content = "#!/bin/sh\n"
		} else {
			// Strip leading blank lines so we can ensure the shebang is line 1
			trimmed := strings.TrimLeft(content, "\r\n")

			if !strings.HasPrefix(trimmed, "#!") {
				// Prepend shebang if it's not already there
				content = "#!/bin/sh\n" + trimmed
			} else {
				// Already has a shebang at the top after trimming blank lines
				content = trimmed
			}
		}

		mode := os.FileMode(0644)
		if executable {
			mode = 0755
		}

		return os.WriteFile(path, []byte(content), mode)
	}

	var cfg string
	ctidHash := utils.HashIntToNLetters(int(ctid), 5)

	cfg += JAIL_CONF_PREAMBLE
	cfg += fmt.Sprintf("%s {\n", ctidHash)
	cfg += fmt.Sprintf("\t$ctid = \"%s\";\n", ctidHash)

	if data.Hostname != "" {
		cfg += fmt.Sprintf("\thost.hostname = \"%s\";\n", data.Hostname)
	} else {
		cfg += fmt.Sprintf("\thost.hostname = \"%s\";\n", utils.MakeValidHostname(data.Name))
	}

	// Jail root filesystem path
	cfg += fmt.Sprintf("\tpath = \"%s\";\n\n", mountPoint)

	// Allowed options
	if len(data.AllowedOptions) > 0 {
		for _, opt := range data.AllowedOptions {
			cfg += fmt.Sprintf("\t%s;\n", opt)
		}
		cfg += "\n"
	}

	// devfs mount and rules
	if data.AllowedOptions != nil && utils.StringInSlice("allow.mount.devfs", data.AllowedOptions) {
		cfg += "\tmount.devfs;\n"

		if data.DevFSRuleset != "" {
			cfg += fmt.Sprintf("\tdevfs_ruleset=%d;\n\n", ctid)
		} else {
			// default ruleset
			cfg += "\tdevfs_ruleset=61181;\n\n"
		}
	}

	var preStartCfg, startCfg, postStartCfg, preStopCfg, stopCfg, postStopCfg string

	if len(data.Networks) > 0 {
		if mac == "" {
			return "", fmt.Errorf("missing_mac_for_network")
		}

		var networkId string

		network := data.Networks[0]
		if network.SwitchID > 0 {
			// Use network database ID for unique interface naming
			networkId = fmt.Sprintf("net%d", network.ID)

			cfg += "\tvnet;\n"
			cfg += fmt.Sprintf("\tvnet.interface = \"%s_%sb\";\n", ctidHash, networkId)

			prevMAC, err := utils.PreviousMAC(mac)
			if err != nil {
				return "", fmt.Errorf("failed to get previous mac: %w", err)
			}

			// ### Start Sylve-Managed Network ###
			preStartCfg += "### Start Sylve-Managed Network ###\n\n"
			preStartCfg += fmt.Sprintf("# Setup Network Interface %s_%sb\n", ctidHash, networkId)
			preStartCfg += fmt.Sprintf("ifconfig %s_%sa ether %s up\n", ctidHash, networkId, prevMAC)
			preStartCfg += fmt.Sprintf("ifconfig %s_%sb ether %s up\n", ctidHash, networkId, mac)
			preStartCfg += "\n"

			bridgeName, err := s.NetworkService.GetBridgeNameByIDType(network.SwitchID, network.SwitchType)
			if err != nil {
				return "", fmt.Errorf("failed to get bridge name: %w", err)
			}

			preStartCfg += fmt.Sprintf("if ! ifconfig %s | grep -qw %s_%sa; then\n",
				bridgeName, ctidHash, networkId)
			preStartCfg += fmt.Sprintf("\tifconfig %s addm %s_%sa 2>&1 || true\n",
				bridgeName, ctidHash, networkId)
			preStartCfg += "fi\n"
			preStartCfg += fmt.Sprintf("# End Setup Network Interface %s_%sb\n", ctidHash, networkId)
			preStartCfg += "### End Sylve-Managed Network ###\n\n"
		}

		// DHCP / SLAAC / static config inside jail â€” FreeBSD JAILS ONLY
		if data.Type == jailModels.JailTypeFreeBSD {
			ifName := fmt.Sprintf("ifconfig_%s_%sb", ctidHash, networkId)
			lineDHCP := fmt.Sprintf("%s=\"SYNCDHCP\"\n", ifName)
			ipv6Name := fmt.Sprintf("%s_ipv6", ifName)
			lineSLAAC := fmt.Sprintf("%s=\"inet6 accept_rtadv\"\n", ipv6Name)

			rcF, err := os.OpenFile(rcConfPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
			if err != nil {
				return "", fmt.Errorf("open rc.conf: %w", err)
			}

			defer rcF.Close()

			b, err := os.ReadFile(rcConfPath)
			if err != nil && !os.IsNotExist(err) {
				return "", fmt.Errorf("read rc.conf: %w", err)
			}

			existing := string(b)
			var rcToAppend strings.Builder

			if network.DHCP {
				if !strings.Contains(existing, lineDHCP) {
					rcToAppend.WriteString(lineDHCP)
				}
			} else {
				if (network.IPv4ID != nil && *network.IPv4ID > 0) && (network.IPv4GwID != nil && *network.IPv4GwID > 0) {
					ipv4Addr, err := s.NetworkService.GetObjectEntryByID(*network.IPv4ID)
					if err != nil {
						return "", fmt.Errorf("failed_to_get_ipv4_address_object: %w", err)
					}

					ip, mask, err := utils.SplitIPv4AndMask(ipv4Addr)
					if err != nil {
						return "", fmt.Errorf("failed_to_split_ipv4_address_and_mask: %w", err)
					}

					lineIPv4 := fmt.Sprintf("%s=\"inet %s netmask %s\"\n", ifName, ip, mask)
					if !strings.Contains(existing, lineIPv4) {
						rcToAppend.WriteString(lineIPv4)
					}

					if network.IPv4GwID != nil && *network.IPv4GwID > 0 {
						ipv4GwAddr, err := s.NetworkService.GetObjectEntryByID(*network.IPv4GwID)
						if err != nil {
							return "", fmt.Errorf("failed_to_get_ipv4_gateway_object: %w", err)
						}

						lineGw4 := fmt.Sprintf("defaultrouter=\"%s\"\n", ipv4GwAddr)
						if !strings.Contains(existing, lineGw4) {
							rcToAppend.WriteString(lineGw4)
						}
					}
				}
			}

			if network.SLAAC {
				if !strings.Contains(existing, lineSLAAC) {
					rcToAppend.WriteString(lineSLAAC)
				}
			}

			if network.IPv6ID != nil && *network.IPv6ID > 0 {
				ipv6Addr, err := s.NetworkService.GetObjectEntryByID(*network.IPv6ID)
				if err != nil {
					return "", fmt.Errorf("failed_to_get_ipv6_address_object: %w", err)
				}

				lineIPv6 := fmt.Sprintf("%s=\"inet6 %s\"\n", ipv6Name, ipv6Addr)
				if !strings.Contains(existing, lineIPv6) {
					rcToAppend.WriteString(lineIPv6)
				}
			}

			if network.IPv6GwID != nil && *network.IPv6GwID > 0 {
				ipv6GwAddr, err := s.NetworkService.GetObjectEntryByID(*network.IPv6GwID)
				if err != nil {
					return "", fmt.Errorf("failed_to_get_ipv6_gateway_object: %w", err)
				}

				lineGw6 := fmt.Sprintf("ipv6_defaultrouter=\"%s\"\n", ipv6GwAddr)
				if !strings.Contains(existing, lineGw6) {
					rcToAppend.WriteString(lineGw6)
				}
			}

			if len(rcToAppend.String()) > 0 {
				if _, err := rcF.WriteString(rcToAppend.String()); err != nil {
					return "", fmt.Errorf("append to rc.conf: %w", err)
				}
			}
		}
	}

	var inheritLines strings.Builder

	if data.InheritIPv4 {
		inheritLines.WriteString(fmt.Sprintf("\tip4=\"inherit\";\n"))
	}

	if data.InheritIPv6 {
		inheritLines.WriteString(fmt.Sprintf("\tip6=\"inherit\";\n"))
	}

	if inheritLines.Len() > 0 {
		cfg += fmt.Sprintf("\n%s\n", inheritLines.String())
	}

	for _, hook := range data.JailHooks {
		if !hook.Enabled || hook.Script == "" {
			continue
		}

		add := func(buf *string) {
			*buf += "### Start User-Managed Hook ###\n"
			*buf += hook.Script + "\n"
			*buf += "### End User-Managed Hook ###\n"
		}

		switch hook.Phase {
		case jailModels.JailHookPhasePreStart:
			add(&preStartCfg)
		case jailModels.JailHookPhaseStart:
			add(&startCfg)
		case jailModels.JailHookPhasePostStart:
			add(&postStartCfg)
		case jailModels.JailHookPhasePreStop:
			add(&preStopCfg)
		case jailModels.JailHookPhaseStop:
			add(&stopCfg)
		case jailModels.JailHookPhasePostStop:
			add(&postStopCfg)
		}
	}

	cpuCfg, memoryCfg, err := s.CreateHardwareConfig(data)
	if err != nil {
		return "", fmt.Errorf("failed_to_create_hardware_config: %w", err)
	}

	if cpuCfg != "" {
		postStartCfg += cpuCfg + "\n"
	}

	if memoryCfg != "" {
		postStartCfg += memoryCfg + "\n"
	}

	if cpuCfg != "" || memoryCfg != "" {
		postStartCfg += "\n"
	}

	// Logging & env
	cfg += fmt.Sprintf("\texec.consolelog += \"%s\";\n", logPath)
	if data.CleanEnvironment {
		cfg += "\texec.clean;\n"
	}

	// --- Write scripts & wire them into exec.* ---

	// prestart: host environment
	preStartHostPath := filepath.Join(hostScriptsDir, "pre-start.sh")
	if err := writeScript(preStartHostPath, preStartCfg, true); err != nil {
		return "", fmt.Errorf("failed_to_write_pre_start_script: %w", err)
	}
	if preStartCfg != "" {
		cfg += fmt.Sprintf("\texec.prestart += \"%s\";\n", preStartHostPath)
	}

	// start: jail environment -> needs inside-jail path
	startHostPath := filepath.Join(hostScriptsDir, "start.sh")
	if err := writeScript(startHostPath, startCfg, true); err != nil {
		return "", fmt.Errorf("failed_to_write_start_script: %w", err)
	}
	startJailFsPath := filepath.Join(jailScriptsFsDir, "start.sh")
	if err := writeScript(startJailFsPath, startCfg, true); err != nil {
		return "", fmt.Errorf("failed_to_write_in_jail_start_script: %w", err)
	}
	startJailExecPath := "/" + filepath.Join(jailScriptsRelDir, "start.sh")
	if startCfg != "" {
		cfg += fmt.Sprintf("\texec.start += \"%s\";\n", startJailExecPath)
	}

	// poststart: host environment
	postStartHostPath := filepath.Join(hostScriptsDir, "post-start.sh")
	if err := writeScript(postStartHostPath, postStartCfg, true); err != nil {
		return "", fmt.Errorf("failed_to_write_post_start_script: %w", err)
	}
	if postStartCfg != "" {
		cfg += fmt.Sprintf("\texec.poststart += \"%s\";\n", postStartHostPath)
	}

	// prestop: host environment
	preStopHostPath := filepath.Join(hostScriptsDir, "pre-stop.sh")
	if err := writeScript(preStopHostPath, preStopCfg, true); err != nil {
		return "", fmt.Errorf("failed_to_write_pre_stop_script: %w", err)
	}
	if preStopCfg != "" {
		cfg += fmt.Sprintf("\texec.prestop += \"%s\";\n", preStopHostPath)
	}

	// stop: jail environment -> needs inside-jail path
	stopHostPath := filepath.Join(hostScriptsDir, "stop.sh")
	if err := writeScript(stopHostPath, stopCfg, true); err != nil {
		return "", fmt.Errorf("failed_to_write_stop_script: %w", err)
	}
	stopJailFsPath := filepath.Join(jailScriptsFsDir, "stop.sh")
	if err := writeScript(stopJailFsPath, stopCfg, true); err != nil {
		return "", fmt.Errorf("failed_to_write_in_jail_stop_script: %w", err)
	}
	stopJailExecPath := "/" + filepath.Join(jailScriptsRelDir, "stop.sh")
	if stopCfg != "" {
		cfg += fmt.Sprintf("\texec.stop += \"%s\";\n", stopJailExecPath)
	}

	// poststop: host environment
	postStopHostPath := filepath.Join(hostScriptsDir, "post-stop.sh")
	if err := writeScript(postStopHostPath, postStopCfg, true); err != nil {
		return "", fmt.Errorf("failed_to_write_post_stop_script: %w", err)
	}
	if postStopCfg != "" {
		cfg += fmt.Sprintf("\texec.poststop += \"%s\";\n", postStopHostPath)
	}

	// fstab if any (mount.fstab, host-side path)
	if data.Fstab != "" {
		fstabPath := filepath.Join(jailDir, "fstab")
		if err := os.WriteFile(fstabPath, []byte(data.Fstab), 0644); err != nil {
			return "", fmt.Errorf("failed_to_write_fstab_file: %w", err)
		}
		cfg += fmt.Sprintf("\tmount.fstab = \"%s\";\n\n", fstabPath)
	}

	// User additional options
	if data.AdditionalOptions != "" {
		cfg += "\n### These are user-defined additional options ###\n"
		cfg += "\n" + data.AdditionalOptions + "\n"
	}

	if data.MetadataMeta != "" {
		cfg += fmt.Sprintf("\tmeta = \"%s\";\n", data.MetadataMeta)
	}

	if data.MetadataEnv != "" {
		cfg += fmt.Sprintf("\tenv = \"%s\";\n", data.MetadataEnv)
	}

	cfg += "\n\tpersist;\n"
	cfg += "}\n"

	return cfg, nil
}

func (s *Service) rollbackJailCreation(ctx context.Context, state *jailServiceInterfaces.JailCreationState) {
	if state == nil {
		return
	}

	if state.JailDir != "" {
		if err := os.RemoveAll(state.JailDir); err != nil {
			logger.L.Error().Err(err).Str("jail_dir", state.JailDir).
				Msg("rollback_jail_creation: failed to remove jail directory")
		}
	}

	if state.DatasetName != "" {
		ds, err := s.GZFS.ZFS.Get(ctx, state.DatasetName, false)
		if err != nil {
			logger.L.Error().Err(err).Str("dataset", state.DatasetName).
				Msg("rollback_jail_creation: failed to get dataset")
		} else if ds != nil {
			err := ds.Destroy(ctx, true, false)
			if err != nil {
				logger.L.Error().Err(err).Str("dataset", state.DatasetName).
					Msg("rollback_jail_creation: failed to destroy dataset")
			}
		}
	}

	if state.CTID != 0 {
		if err := s.RemoveDevfsRulesForCTID(state.CTID); err != nil {
			logger.L.Error().Err(err).Uint("ctid", state.CTID).
				Msg("rollback_jail_creation: failed to remove devfs rules block")
		}
	}
}

func (s *Service) CreateJail(ctx context.Context, data jailServiceInterfaces.CreateJailRequest) (err error) {
	if err = s.ValidateCreate(ctx, data); err != nil {
		logger.L.Debug().Err(err).Msg("create_jail: validation failed")
		return err
	}

	state := &jailServiceInterfaces.JailCreationState{
		CTID: *data.CTID,
	}

	tx := s.DB.Begin()
	if tx.Error != nil {
		return fmt.Errorf("failed_to_begin_tx: %w", tx.Error)
	}

	txCommitted := false
	defer func() {
		if err != nil && !txCommitted {
			_ = tx.Rollback()
			s.rollbackJailCreation(ctx, state)
		}
	}()

	var jail jailModels.Jail

	jail.Name = data.Name
	jail.CTID = *data.CTID
	jail.Description = data.Description
	jail.StartAtBoot = data.StartAtBoot
	jail.StartOrder = data.StartOrder
	jail.ResourceLimits = data.ResourceLimits
	jail.AdditionalOptions = data.AdditionalOptions
	jail.Fstab = data.Fstab
	jail.AllowedOptions = data.AllowedOptions
	jail.Type = data.Type
	jail.MetadataEnv = data.MetadataEnv
	jail.MetadataMeta = data.MetadataMeta

	if data.CleanEnvironment != nil {
		jail.CleanEnvironment = *data.CleanEnvironment
	} else {
		jail.CleanEnvironment = false
	}

	jail.JailHooks = []jailModels.JailHooks{
		{
			Phase:   jailModels.JailHookPhasePreStart,
			Enabled: data.Hooks.Prestart.Enabled,
			Script:  data.Hooks.Prestart.Script,
		},
		{
			Phase:   jailModels.JailHookPhaseStart,
			Enabled: data.Hooks.Start.Enabled,
			Script:  data.Hooks.Start.Script,
		},
		{
			Phase:   jailModels.JailHookPhasePostStart,
			Enabled: data.Hooks.Poststart.Enabled,
			Script:  data.Hooks.Poststart.Script,
		},
		{
			Phase:   jailModels.JailHookPhasePreStop,
			Enabled: data.Hooks.Prestop.Enabled,
			Script:  data.Hooks.Prestop.Script,
		},
		{
			Phase:   jailModels.JailHookPhaseStop,
			Enabled: data.Hooks.Stop.Enabled,
			Script:  data.Hooks.Stop.Script,
		},
		{
			Phase:   jailModels.JailHookPhasePostStop,
			Enabled: data.Hooks.Poststop.Enabled,
			Script:  data.Hooks.Poststop.Script,
		},
	}

	if jail.ResourceLimits != nil && *jail.ResourceLimits {
		jail.Cores = *data.Cores
		jail.Memory = *data.Memory
	} else {
		jail.Cores = 0
		jail.Memory = 0
	}

	jail.DevFSRuleset = data.DevFSRuleset

	// Create networks first to get their database IDs
	var createdNetworks []jailModels.Network
	var macStr string

	if strings.ToLower(data.SwitchName) != "inherit" && strings.ToLower(data.SwitchName) != "none" {
		var mac uint
		if data.MAC != nil {
			mac = uint(*data.MAC)
		}

		swType := ""
		swName := ""
		swID := uint(0)

		var stdSwitch networkModels.StandardSwitch
		if err = tx.First(&stdSwitch, "name = ?", data.SwitchName).Error; err == nil {
			swType = "standard"
			swName = stdSwitch.Name
			swID = stdSwitch.ID
		}

		var manualSwitch networkModels.ManualSwitch
		if err = tx.First(&manualSwitch, "name = ?", data.SwitchName).Error; err == nil {
			swType = "manual"
			swName = manualSwitch.Name
			swID = manualSwitch.ID
		}

		if swType == "" {
			err = fmt.Errorf("switch_not_found: %s", data.SwitchName)
			return
		}

		if mac == 0 {
			base := fmt.Sprintf("%s-%s", data.Name, swName)
			name := base

			for i := 0; ; i++ {
				if i > 0 {
					name = fmt.Sprintf("%s-%d", base, i)
				}
				var exists int64
				if err = tx.
					Model(&networkModels.Object{}).
					Where("name = ?", name).
					Limit(1).
					Count(&exists).Error; err != nil {
					err = fmt.Errorf("failed_to_check_mac_object_exists: %w", err)
					return
				}
				if exists == 0 {
					break
				}
			}

			macAddress := utils.GenerateRandomMAC()
			macObj := networkModels.Object{
				Type: "Mac",
				Name: name,
			}

			macStr = macAddress

			if err = tx.Create(&macObj).Error; err != nil {
				err = fmt.Errorf("failed_to_create_mac_object: %w", err)
				return
			}

			macEntry := networkModels.ObjectEntry{
				ObjectID: macObj.ID,
				Value:    macAddress,
			}

			if err = tx.Create(&macEntry).Error; err != nil {
				err = fmt.Errorf("failed_to_create_mac_entry: %w", err)
				return
			}

			mac = macObj.ID
		} else {
			var macEntry string
			macEntry, err = s.NetworkService.GetObjectEntryByID(mac)
			if err != nil {
				err = fmt.Errorf("failed_to_get_mac_entry: %w", err)
				return
			}

			macStr = macEntry
		}

		var ipv4ID, ipv4GwID, ipv6ID, ipv6GwID *uint
		if data.IPv4 != nil {
			ipv4ID = new(uint)
			*ipv4ID = uint(*data.IPv4)
		}

		if data.IPv4Gw != nil {
			ipv4GwID = new(uint)
			*ipv4GwID = uint(*data.IPv4Gw)
		}

		if data.IPv6 != nil {
			ipv6ID = new(uint)
			*ipv6ID = uint(*data.IPv6)
		}

		if data.IPv6Gw != nil {
			ipv6GwID = new(uint)
			*ipv6GwID = uint(*data.IPv6Gw)
		}

		dhcp := false
		slaac := false

		if data.DHCP != nil && *data.DHCP {
			dhcp = *data.DHCP
		}

		if data.SLAAC != nil && *data.SLAAC {
			slaac = *data.SLAAC
		}

		// Create the network record first to get its ID
		network := jailModels.Network{
			Name:           fmt.Sprintf("Initial Switch - %s - %s", swName, data.Name),
			SwitchID:       swID,
			SwitchType:     swType,
			MacID:          &mac,
			IPv4ID:         ipv4ID,
			IPv4GwID:       ipv4GwID,
			IPv6ID:         ipv6ID,
			IPv6GwID:       ipv6GwID,
			DHCP:           dhcp,
			SLAAC:          slaac,
			DefaultGateway: true,
		}

		if err = tx.Create(&network).Error; err != nil {
			err = fmt.Errorf("failed_to_create_network: %w", err)
			return
		}

		createdNetworks = append(createdNetworks, network)
	}

	if data.InheritIPv4 != nil {
		jail.InheritIPv4 = *data.InheritIPv4
	}

	if data.InheritIPv6 != nil {
		jail.InheritIPv6 = *data.InheritIPv6
	}

	datasetName := fmt.Sprintf("%s/sylve/jails/%d", data.Pool, *data.CTID)
	mountPoint := fmt.Sprintf("/%s/sylve/jails/%d", data.Pool, *data.CTID)

	var dataset *gzfs.Dataset
	dataset, err = s.GZFS.ZFS.CreateFilesystem(ctx, datasetName, map[string]string{})
	if err != nil || dataset == nil {
		if err == nil {
			err = fmt.Errorf("nil_dataset_returned")
		}

		err = fmt.Errorf("failed_to_create_jail_dataset: %w", err)
		return
	}

	state.DatasetName = datasetName

	jail.Storages = append(jail.Storages, jailModels.Storage{
		Pool:   data.Pool,
		GUID:   dataset.GUID,
		Name:   "Base Filesystem",
		IsBase: true,
	})

	// Associate the created networks with the jail
	jail.Networks = createdNetworks

	// Check if a jail with this CTID already exists
	var existingJail jailModels.Jail
	if err = tx.Where("ct_id = ?", jail.CTID).First(&existingJail).Error; err == nil {
		// Jail already exists - this is an error, don't overwrite existing jails
		logger.L.Error().Uint("ctid", jail.CTID).Msg("jail with this CTID already exists")
		err = fmt.Errorf("jail_with_ctid_%d_already_exists", jail.CTID)
		return
	} else if err != gorm.ErrRecordNotFound {
		// Some other database error occurred
		logger.L.Error().Err(err).Uint("ctid", jail.CTID).Msg("failed to check for existing jail")
		err = fmt.Errorf("failed_to_check_existing_jail: %w", err)
		return
	}

	// Now create the jail record and associate it with the networks
	if err = tx.Create(&jail).Error; err != nil {
		logger.L.Error().Err(err).Msg("create_jail: failed to create jail")
		err = fmt.Errorf("failed_to_create_jail: %w", err)
		return
	}

	// Update network records to link them to the jail
	for i := range createdNetworks {
		createdNetworks[i].JailID = jail.ID
		if err = tx.Save(&createdNetworks[i]).Error; err != nil {
			logger.L.Error().Err(err).Msg("create_jail: failed to update network jail association")
			err = fmt.Errorf("failed_to_update_network_jail_association: %w", err)
			return
		}
	}

	// Update jail.Networks to reflect the saved state with proper JailID
	jail.Networks = createdNetworks

	// Commit the transaction before the potentially long-running file copy
	if err = tx.Commit().Error; err != nil {
		/*
			2025/12/05 06:53:39 /zroot/projects/Sylve/internal/services/jail/jail.go:1081 duplicated key not allowed
			[0.167ms] [rows:0] INSERT INTO `jail_networks` (`jid`,`name`,`switch_id`,`switch_type`,`mac_id`,`ipv4_id`,`ipv4_gw_id`,`ipv6_id`,`ipv6_gw_id`,`default_gateway`,`dhcp`,`sla_ac`) VALUES (53,"Initial Switch",1,"manual",42,0,0,0,0,true,false,false) ON CONFLICT (`id`) DO UPDATE SET `jid`=`excluded`.`jid` RETURNING `id`
		*/
		// ^ If duplicate just continue?
		if strings.Contains(err.Error(), "duplicated key not allowed") {
			err = nil
		} else {
			err = fmt.Errorf("failed_to_commit_tx: %w", err)
			return
		}
	}
	txCommitted = true

	// From this point on, we need to handle rollback manually if anything fails
	defer func() {
		if err != nil {
			s.rollbackJailCreation(ctx, state)
			// Also delete the jail record from database
			if deleteErr := s.DB.Delete(&jail).Error; deleteErr != nil {
				logger.L.Error().Err(deleteErr).Uint("ctid", jail.CTID).
					Msg("failed to delete jail record during rollback")
			}
		}
	}()

	var base string
	base, err = s.FindBaseByUUID(data.Base)
	if err != nil {
		err = fmt.Errorf("failed_to_find_base: %w", err)
		return
	}

	isDir, _ := utils.IsDir(base)
	if isDir {
		if err = utils.CopyDirContents(base, mountPoint); err != nil {
			err = fmt.Errorf("failed_to_copy_base: %w", err)
			return
		}
	} else {
		err = fmt.Errorf("base_is_not_a_directory")
		return
	}

	var jailsPath string
	jailsPath, err = config.GetJailsPath()
	if err != nil {
		err = fmt.Errorf("failed_to_get_jails_path: %w", err)
		return
	}

	if jailsPath == "" {
		err = fmt.Errorf("jails_path_not_found")
		return
	}

	jailDir := filepath.Join(jailsPath, fmt.Sprintf("%d", *data.CTID))
	if err = os.MkdirAll(jailDir, 0755); err != nil {
		err = fmt.Errorf("failed_to_create_jail_directory: %w", err)
		return
	}

	state.JailDir = jailDir

	logsPath := filepath.Join(jailDir, fmt.Sprintf("%d.log", *data.CTID))
	if err = os.WriteFile(logsPath, []byte(""), 0644); err != nil {
		err = fmt.Errorf("failed_to_write_log_file: %w", err)
		return
	}

	fstabPath := filepath.Join(jailDir, "fstab")
	if err = os.WriteFile(fstabPath, []byte(jail.Fstab), 0644); err != nil {
		err = fmt.Errorf("failed_to_write_fstab_file: %w", err)
		return
	}

	var jCfg string
	jCfg, err = s.CreateJailConfig(jail, mountPoint, macStr)
	if err != nil {
		err = fmt.Errorf("failed_to_create_jail_config: %w", err)
		return
	}

	jailConfigPath := filepath.Join(jailDir, fmt.Sprintf("%d.conf", *data.CTID))
	if err = os.WriteFile(jailConfigPath, []byte(jCfg), 0644); err != nil {
		err = fmt.Errorf("failed_to_write_jail_config_file: %w", err)
		return
	}

	sylveDir := filepath.Join(mountPoint, ".sylve")
	if err = os.MkdirAll(sylveDir, 0755); err != nil {
		err = fmt.Errorf("failed_to_create_sylve_directory: %w", err)
		return
	}

	err = s.WriteJailJSON(*data.CTID)
	if err != nil {
		logger.L.Error().Err(err).Msg("Failed to write jail metadata")
		return
	}

	return nil
}

func (s *Service) DeleteJail(ctx context.Context, ctId uint, deleteMacs bool, deleteRootFS bool) error {
	if ctId == 0 {
		return fmt.Errorf("invalid_ct_id")
	}

	jail, err := s.GetJailByCTID(ctId)
	if err != nil {
		return err
	}

	if len(jail.Networks) > 0 {
		for _, network := range jail.Networks {
			if err := s.DB.Delete(&network).Error; err != nil {
				logger.L.Error().Err(err).Msg("delete_jail: failed to delete network")
				return fmt.Errorf("failed_to_delete_network: %w", err)
			}
		}
	}

	if err := s.DB.Delete(&jail).Error; err != nil {
		return fmt.Errorf("failed_to_delete_jail: %w", err)
	}

	jailsPath, err := config.GetJailsPath()
	if err != nil {
		return fmt.Errorf("failed_to_get_jails_path: %w", err)
	}

	jailDir := filepath.Join(jailsPath, fmt.Sprintf("%d", ctId))
	if err := os.RemoveAll(jailDir); err != nil {
		return fmt.Errorf("failed_to_remove_jail_directory: %w", err)
	}

	if deleteMacs {
		var usedMACS []uint

		for _, network := range jail.Networks {
			macId := network.MacID
			if macId != nil {
				usedMACS = append(usedMACS, *macId)
			}
		}

		if len(usedMACS) > 0 {
			tx := s.DB.Begin()

			if err := tx.Where("object_id IN ?", usedMACS).
				Delete(&networkModels.ObjectEntry{}).Error; err != nil {
				tx.Rollback()
				return fmt.Errorf("failed_to_delete_object_entries: %w", err)
			}

			if err := tx.Where("object_id IN ?", usedMACS).
				Delete(&networkModels.ObjectResolution{}).Error; err != nil {
				tx.Rollback()
				return fmt.Errorf("failed_to_delete_object_resolutions: %w", err)
			}

			if err := tx.Delete(&networkModels.Object{}, usedMACS).Error; err != nil {
				tx.Rollback()
				return fmt.Errorf("failed_to_delete_objects: %w", err)
			}

			if err := tx.Commit().Error; err != nil {
				return fmt.Errorf("failed_to_commit_cleanup: %w", err)
			}
		}
	}

	if deleteRootFS {
		if len(jail.Storages) > 0 {
			for _, storage := range jail.Storages {
				if storage.IsBase {
					dataset, err := s.GZFS.ZFS.Get(ctx, fmt.Sprintf("%s/sylve/jails/%d", storage.Pool, ctId), true)
					if err != nil {
						return fmt.Errorf("failed_to_get_dataset_for_storage: %w", err)
					}

					if dataset == nil {
						continue
					}

					if err := dataset.Destroy(ctx, true, false); err != nil {
						return fmt.Errorf("failed_to_destroy_storage_dataset: %w", err)
					}
				}
			}
		}
	}

	return nil
}

func (s *Service) UpdateDescription(id uint, description string) error {
	if id == 0 {
		return fmt.Errorf("invalid_jail_id")
	}

	if len(description) > 1024 {
		return fmt.Errorf("invalid_description")
	}

	if err := s.DB.Model(&jailModels.Jail{}).
		Where("id = ?", id).
		Update("description", description).Error; err != nil {

		logger.L.Error().Err(err).
			Msg("update_jail_description: failed to update jail description")

		return fmt.Errorf("failed_to_update_jail_description: %w", err)
	}

	var ctid uint
	if err := s.DB.Model(&jailModels.Jail{}).
		Select("ct_id").
		Where("id = ?", id).
		Take(&ctid).Error; err == nil {

		_ = s.WriteJailJSON(ctid)
	}

	return nil
}

func (s *Service) WriteJailJSON(ctId uint) error {
	if ctId == 0 {
		return fmt.Errorf("invalid_ct_id")
	}

	jail, err := s.GetJailByCTID(ctId)
	if err != nil {
		return err
	}

	var mountPoints []string
	for _, storage := range jail.Storages {
		if storage.IsBase {
			mountPoints = append(mountPoints, fmt.Sprintf("/%s/sylve/jails/%d", storage.Pool, ctId))
		}
	}

	for _, mountPoint := range mountPoints {
		sylveDir := filepath.Join(mountPoint, ".sylve")
		if err := os.MkdirAll(sylveDir, 0755); err != nil {
			return fmt.Errorf("failed_to_create_.sylve_directory: %w", err)
		}

		jailJsonPath := filepath.Join(sylveDir, "jail.json")
		jailJsonData, err := json.MarshalIndent(jail, "", "  ")
		if err != nil {
			return fmt.Errorf("failed_to_marshal_jail_to_json: %w", err)
		}

		if err := os.WriteFile(jailJsonPath, jailJsonData, 0644); err != nil {
			return fmt.Errorf("failed_to_write_jail_json_file: %w", err)
		}
	}

	return nil
}
